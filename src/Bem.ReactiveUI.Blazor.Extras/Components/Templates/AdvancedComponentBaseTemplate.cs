// <auto-generated/>
// --------------------------------------
// <copyright file="AdvancedComponentBaseTemplate.cs" company="Daniel Balogh">
//     Copyright (c) Daniel Balogh. All rights reserved.
//     Licensed under the GNU Generic Public License 3.0 license.
//     See LICENSE file in the project root for full license information.
// </copyright>
// --------------------------------------
#nullable enable

using System.CodeDom.Compiler;
using Bem.ReactiveUI.Blazor.Extras.Extensions;
using Bem.ReactiveUI.Blazor.Extras.Internal.Bindings;

namespace Bem.ReactiveUI.Blazor.Extras.Components.Templates
{
    [GeneratedCode("Bem.ReactiveUI.Blazor.Extras.CodeGenerators", "1.0.0")]
    abstract partial class AdvancedComponentBaseTemplate<TViewModel> : IHandleEvent, IAdvancedComponent
        where TViewModel : class, INotifyPropertyChanged
    {
        private static FieldInfo _renderFragmentField = typeof(ComponentBase).GetField("_renderFragment", BindingFlags.Instance | BindingFlags.NonPublic)!;

        private ParameterView _oldParameters;

        /// <summary>
        /// Initializes a new instance of <see cref="AdvancedComponentBase{TViewModel}"/>.
        /// </summary>
        protected AdvancedComponentBaseTemplate()
        {
            _oldParameters = ParameterViewExtensions.Empty;
            InlineBindings = new InlineBindingStore();

            var renderFragment = (RenderFragment)_renderFragmentField.GetValue(this)!;
            RenderFragment newRenderFragment = builder =>
            {
                renderFragment(builder);
                InlineBindings.Sweep();
            };
            _renderFragmentField.SetValue(this, newRenderFragment);
        }

        internal InlineBindingStore InlineBindings { get; }

        /// <summary>
        /// Gets or sets if rendering forced after event handled.
        /// Components directly inherited from <see cref="ComponentBase" /> rerenders automatically after a handled event by initiating a <see cref="StateHasChanged()"/> call. This behavior is overridden for components inherited from <see cref="AdvancedComponentBase{TViewModel}"/> in order to reduce redundant renders. The default value is <code>false</code>.
        /// </summary>
        protected internal bool ForceRenderOnEvent { get; set; } = false;

        private bool IsChanged { get; set; }

        private bool HasMutableParameters { get; set; }

        private bool IsDisposed { get; set; }

        /// <inheritdoc />
        public override Task SetParametersAsync(ParameterView parameters)
        {
            var newParameters = _oldParameters.UpdateWith(parameters);
            (IsChanged, HasMutableParameters) = newParameters.Compare(_oldParameters);

            _oldParameters = newParameters;

            return base.SetParametersAsync(parameters);
        }

        #region IDisposable

        /// <inheritdoc />
        public new void Dispose()
        {
            ((IDisposable)this).Dispose();
        }

        /// <inheritdoc />
        void IDisposable.Dispose()
        {
            base.Dispose();
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        #endregion

        /// <inheritdoc />
        Task IHandleEvent.HandleEventAsync(EventCallbackWorkItem callback, object? arg)
        {
            IsChanged = ForceRenderOnEvent || HasMutableParameters;

            return this.HandleEventAsync(callback, arg);
        }

        /// <inheritdoc />
        void IAdvancedComponent.StateHasChanged()
        {
            StateHasChanged();
        }

        /// <inheritdoc />
        protected internal new void StateHasChanged()
        {
            IsChanged = true;

            _ = InvokeAsync(base.StateHasChanged);
        }

        /// <inheritdoc />
        protected override bool ShouldRender() => IsChanged;

        /// <inheritdoc />
        protected override void OnAfterRender(bool firstRender)
        {
            IsChanged = false;

            base.OnAfterRender(firstRender);
        }

        /// <summary>
        /// Creates a binding (subscribes for the modifications of the property chain) and returns the value of the property.
        /// </summary>
        /// <typeparam name="TValue">The type of the property to subscribe for.</typeparam>
        /// <param name="propertyExpression">The expression representing the property chain.</param>
        /// <returns>The value of the property</returns>
        protected internal TValue? From<TValue>(Expression<Func<AdvancedComponentBaseTemplate<TViewModel>, TValue>> propertyExpression) =>
            InlineBindings.Bind(this, propertyExpression).As<IInlineBinding<TValue>>()!.Value;

        /// <summary>
        /// Creates a binding (subscribes for the modifications of the property chain) and returns null so that the return value has no rendered output.
        /// This method is basically an alias for <see cref="SubscribeTo{TValue}"/> with the intention to reduce typing when creating the binding inline in a HTML attribute of a component.
        /// </summary>
        /// <typeparam name="TValue">The type of the property to subscribe for.</typeparam>
        /// <param name="propertyExpression">The expression representing the property chain.</param>
        /// <returns>null</returns>
        protected internal string? To<TValue>(Expression<Func<AdvancedComponentBaseTemplate<TViewModel>, TValue>> propertyExpression)
        {
            _ = InlineBindings.Bind(this, propertyExpression);
            return null;
        }

        /// <summary>
        /// Creates a binding (subscribes for the modifications of the property chain) and returns null so that the return value has no rendered output.
        /// </summary>
        /// <typeparam name="TValue">The type of the property to subscribe for.</typeparam>
        /// <param name="propertyExpression">The expression representing the property chain.</param>
        /// <returns>null</returns>
        protected internal string? SubscribeTo<TValue>(
            Expression<Func<AdvancedComponentBaseTemplate<TViewModel>, TValue>> propertyExpression) =>
            To(propertyExpression);

        /// <inheritdoc />
        protected new void Dispose(bool disposing)
        {
            base.Dispose(disposing);

            if (!IsDisposed && disposing)
            {
                InlineBindings.Dispose();
                IsDisposed = true;
            }
        }
        
        private static Func<ComponentBase, RenderFragment> CreateGetter()
        {
            var thisExpression = Expression.Parameter(typeof(ComponentBase));
            return Expression.Lambda<Func<ComponentBase, RenderFragment>>(Expression.Field(thisExpression, typeof(ComponentBase).GetField("_renderFragment", BindingFlags.Instance | BindingFlags.NonPublic)!), thisExpression).Compile();
        }
    }
}